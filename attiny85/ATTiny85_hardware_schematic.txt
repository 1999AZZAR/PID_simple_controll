BLDC PID Controller - ATtiny85 Production Version
===============================================

PRODUCTION CONFIGURATION - No Potentiometers Required!
All PID gains are pre-tuned and hardcoded from Arduino development.

ATtiny85 Physical Pin Mapping:
+---------------------+
|  RST (1)  VCC (8)  |
|  PB3 (2)  PB2 (7)  |
|  PB4 (3)  PB1 (6)  |
|  GND (4)  PB0 (5)  |
+---------------------+

REQUIRED CONNECTIONS (Only 2 Pins!):
===================================

RPM Sensor Input:
- Signal wire → ATtiny85 Physical Pin 2 (PB3)
- Power → 5V
- Ground → GND
- Note: PB3 is interrupt-capable (INT0) for accurate RPM counting

PWM Output to ESC:
- ATtiny85 Physical Pin 5 (PB0) → ESC signal input
- Note: Timer0-based PWM (~1kHz frequency)

PROGRAMMING CONNECTIONS:
=======================

When uploading code:
- Use Arduino as ISP or dedicated programmer
- Connect RESET, MOSI, MISO, SCK pins
- Remove motor power during programming

POWER SUPPLY:
============

- ATtiny85: 2.7-5.5V (use 5V for compatibility)
- Separate supply for motor/ESC (common ground)
- Add decoupling capacitor (10µF) near VCC/GND pins

LIMITATIONS & WORKAROUNDS:
=========================

1. Reduced Potentiometers:
   - Only 3 potentiometers instead of 4
   - Ki and Kd share one potentiometer (time-multiplexed)

2. PWM Limitations:
   - Only one PWM output pin available
   - Timer0 shared between PWM and system timing
   - ~1kHz PWM frequency (may need adjustment for ESC)

3. ADC Constraints:
   - ADC2 (PB4) used for Kp potentiometer
   - ADC3 (PB2) shared between mode switch and Ki/Kd pot
   - ADC1 (PB1) used for target RPM pot

4. Memory Constraints:
   - 512 bytes SRAM (careful with variables)
   - No Serial output for debugging

TUNING PROCEDURE (ATtiny85):
===========================

1. Upload code with Arduino as ISP
2. Connect potentiometers as shown
3. Set mode switch to tuning position (GND)
4. Power on system
5. Adjust potentiometers:
   - Target RPM: Set to 1440
   - Kp: Start low (0.1), increase until oscillation
   - Ki/Kd: Wait for parameter to appear, adjust accordingly
6. Note optimal values
7. Update PRODUCTION_* constants in code
8. Re-upload with tuned values
9. Switch to production mode

ALTERNATIVE TUNING METHOD:
=========================

Since Serial is not available, consider:
- Using LED blink patterns to indicate current values
- EEPROM storage of tuned parameters
- Fixed tuning values based on Arduino testing

COMPILATION NOTES:
=================

- Use ATtiny85 board definition in Arduino IDE
- Clock: 8MHz internal
- Programmer: Arduino as ISP
- Optimize code for size (-Os)
- Remove unused functions

FUSE SETTINGS:
=============

- Low: 0xE2 (8MHz internal clock)
- High: 0xDF (SPM disabled)
- Extended: 0xFF (default)

TROUBLESHOOTING:
===============

1. Motor Not Responding:
   - Check PWM frequency compatibility with ESC
   - Verify PWM pin connection (physical pin 5)
   - Test with fixed PWM value first

2. RPM Not Reading:
   - Verify interrupt pin connection (physical pin 2)
   - Check sensor signal level and pull-up

3. Unstable Control:
   - Reduce PID gains (start with Arduino-tuned values)
   - Check timing calculations
   - Verify control loop frequency

4. Programming Issues:
   - Ensure proper ISP connections
   - Check fuse settings
   - Try external crystal if 8MHz internal unstable
